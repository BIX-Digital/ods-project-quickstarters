BE SECURITY GATEWAY
===================

NOTE: This is an INTERNAL private shared-service which has not been published to the public.
DO NOT PUBLISH OR SHARE THIS QUICKSTARTER WITH THE PUBLIC.

Backend Security Gateway based on [Alpine](https://alpinelinux.org/) Linux with [Openresty](https://openresty.org) ([Nginx](https://nginx.org/en/) wrapper project) HTTP server and [WAF](https://www.owasp.org/index.php/Web_Application_Firewall) (ModSecurity library + Nginx module) application with Lua programming language enabled.
Ready for any API Gateway implementation. Check the [official OpenResty documentation](https://openresty-reference.readthedocs.io/en/latest/).

The container is based on *ods-core/shared-images/openresty-nginx*. See its [README](https://github.com/opendevstack/ods-core/blob/master/shared-images/openresty-nginx/README.md) for further understanding of the underlying architecture and its dependencies and versions.

[ModSecurity](https://modsecurity.org/) is also ready to be used as a WAF with default [OWASP Core Rule Set](https://modsecurity.org/crs/), but disabled by default.
To enable it you need to set *WAF_MODSECURITY* environment variable to *on* (*off* by default) and it will be automatically applied in *nginx.conf*.
For applying different custom configurations and rule sets you will need to update default/provided ones (*modsecurity.conf* or *crs-setup.conf* files, or other custom **.conf* files).

[syslog-ng](https://github.com/balabit/syslog-ng/) (version [3.13](https://www.syslog-ng.com/technical-documents/list/syslog-ng-open-source-edition/3.13)) has been added to the quickstarter in order to be able to send the audit logs generated by ModSecurity to a central managed monitoring and alarm service.

Through [Lua Nginx](https://github.com/openresty/lua-nginx-module#readme) module one can add dynamic configurations and new functionalities. One can find more references [here](https://openresty.org/en/resources.html).

Default behaviour and environment variables
-------------------------------------------

By default this quickstarter is deployed as a proxy forward to any other existing service you might want to point to (and to expose outside in a secure way), but one can easily implement new API Gateway functionalities too (like: dynamic/static routing, access management, request and/or response filtering, ...). The defined OpenShift route is pointing to the default OpenShift DNS route subdomain, starting by its component name (so it is recommended to not leak information within your component's name).

Default parameters to be configured for the default deployement are:

- `SERVICE`: the service to proxy to. Defaults to *change-to-your-target-component-name.${PROJECT}-${devenv}.svc.cluster.local* (you need to define *change-to-your-target-component-name* so to point/proxy to the right OpenShift component service). You can improve and add different endpoints (based on nginx *locations*) to proxy to by adding different *upstreams* or by implementing your routing logic with Lua.
- `SERVER_SIGNATURE`: the server name to be provided in the respective HTTP header (so not exposing known server technologies neither versions, unless required)
- `WAF_MODSECURITY`: off by default. Set to 'on' if WAF is required. See aforementioned Modsecurity topics in this readme file to understand implications of using it. You might need to replace OWASP CRSs that might block already exisiting HTTP requests implemented in your services.
- `SYSLOG_NG`: off by default. If WAF is enabled and `SYSLOG_NG` is set to 'on' then the ModSecurity logs are formatted to JSON and sent by syslog-ng to a remote host defined next:
- `SYSLOG_NG_TO`: 127.0.0.1 by default. If syslog-ng is enabled you will need to define the right destination host/IP to send the logs to, together with right agreed tags to add into the headers in order to be tracked by the central monitoring and alarm service:
- `SYSLOG_NG_TAGS`: agreed set of tags with receiver monitoring and alarm system. Defaults to *`clusterID`-`projectID`-`ENV`* (e.g.: bix-psp-prod).

The given **.conf* files are example files on how to implement specific functionalities with Nginx. For example one would need to manage [CORS](https://enable-cors.org/) issues so you can do that with an nginx config file.

Testing your Lua scripts
------------------------
Test framework used is [luaunit](https://luaunit.readthedocs.io/en/latest).
Testing is done through [resty](https://github.com/openresty/resty-cli) CLI executing your test.lua file:

```
resty -I lua/ lua/test/test.lua --output junit --name lua/test/test.xml
```

The test.lua file is a self-explanatory example; how to develop testing is expected.

The output format is set to JUnit. And it is then loaded into JUnit Jenkins plugin.

Adding offical Lua modules
--------------------------
One can add official Lua modules by using [opm](https://opm.openresty.org/).

In the following code snipped one can see how to add an official Lua module through docker build stage. Inside your Dockerfile:

```docker
RUN opm get pintsized/lua-resty-http \
    && cp -r /etc/nginx/site/lualib/resty /etc/nginx/lua \
    && opm remove pintsized/lua-resty-http
```

Then, one can load such module dependency in new modules like:

```lua
local http = require("resty.http")
```

NOTE: lua-resty-http module is already provided.

Lua examples
------------

Main examples shown here are following the OpenResty [Directives](https://openresty-reference.readthedocs.io/en/latest/Directives/).
Most of the directives require being defined inside your server *locations*.
And, notice the importance of the execution order of the directives.

`1` - Managing access with *access_by_lua_block*

With the provided *auth-crowd.lua* module (see [ods-core/shared-images/nginx-authproxy-crowd/](https://github.com/opendevstack/ods-core/tree/master/shared-images/nginx-authproxy-crowd) implementation), and loading the right *ENV* variables in *nginx.conf*, you can add in your *location* block an HTTP Basic Authentitacion (based on Atlassian Crowd Auth) layer:

```lua
access_by_lua_block {
    require("auth-crowd").run()
}
```

`2` - Managing content with *content_by_lua_block*

With the provided *server-error.lua* module, and loading the right *ENV* variables in *nginx.conf*, you can add in your error *location* block a custom server error handling:

```lua
location = /50x.html {
    content_by_lua_block {
        require("server-error").run(ngx.var.server_signature)
    }
}
```

`3` - Filter incoming requests

Filter incoming requests comming from your clients with *rewrite_by_lua_block*. For example, one could modify the incoming HTTP Header *Authorization*:

```lua
rewrite_by_lua_block {
    require("auth-basic-rewrite").run()
}
```

`4` - Filter body responses

Filter the body responses comming from your Backend services with *body_filter_by_lua_block*. For example, one could filter any error response, so to filter stack traces in a JSON object response:

```lua
body_filter_by_lua_block {
    require("filter-error-response").run()
}
```